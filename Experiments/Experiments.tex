This chapter will illustrate an example of applying the proposed certification scheme to real software, showing how the manufacturer could benefit from such a solution.

\section{Certification Target}
The software considered for this demonstration is OpenSSL, a robust, commercial-grade, full-featured Open Source Toolkit for the Transport Layer Security (TLS) protocol formerly known as the Secure Sockets Layer (SSL) protocol. The protocol implementation is based on a full-strength general-purpose cryptographic library, which can also be used stand-alone.
OpenSSL is descended from the SSLeay library developed by Eric A. Young and Tim J. Hudson []. The OpenSSL crypto library (libcrypto) implements various cryptographic algorithms used in various Internet standards. The services provided by this library are used by the OpenSSL implementations of TLS and CMS, and they have also been used to implement many other third-party products and protocols.
The functionality includes symmetric encryption, public key cryptography, key agreement, certificate handling, cryptographic hash functions, cryptographic pseudo-random number generators, message authentication codes (MACs), key derivation functions (KDFs), and various utilities.

OpenSSL was considered for this demonstration for two main reasons:
\begin{description}
    \item[Open-Source] It is open-source software, which allows browsing through the code (mainly written in the C language) publicly available in the official GitHub repository (https://github.com/openssl/openssl) and inspecting all the previous versions of the software with the relative update changes.
    \item[Vulnerabilities] Researchers found multiple exposed vulnerabilities of the software during the various years of deployment; in this thesis work, only two of them will be considered for the sake of the example, the first identified by the Common Vulnerability Scoring System (CVSS) as [CVE-2014-0224] and the second as [CVE-2016-7798].
    
    \begin{itemize}
        \item {[CVE-2014-0224]} allowed man-in-the-middle attackers [] to use a zero-length master key in certain OpenSSL-to-OpenSSL communications and consequently hijack sessions or obtain sensitive information via a crafted TLS handshake, also known as "CCS Injection" vulnerability [].
        \item {[CVE-2016-7798]} was a vulnerability of the OpenSSL Ruby gem, which used the same initialization vector for multiple encryptions in a specific configuration; this allowed attackers to decipher encrypted messages easily [].

    \end{itemize}
\end{description}

OpenSSL is not a product certified by third-party certification authorities with schemes like Common Criteria, but it will be considered as if it was for this demonstration. With standard approaches, the presence of such vulnerabilities would trigger the certificate revocation, obliging the manufacturer to fix the vulnerability and re-certificate the software with a full certification process, costing a considerable amount of money and time; instead, the proposed scheme would allow performing a faster and cheaper re-certification.

\section{Process Walkthrough}
This section will illustrate a complete walkthrough of the proposed certification scheme over a system based on OpenSSL that has to go through the OpenSSL cryptolibrary update.

\subsection{Trigger Phase}
The bug that exposed the first vulnerability ([CVE-2014-0224]) consisted of a bad implementation of the DTLS handshake protocol [], which allowed bad actors to defeat any encryption algorithm used effortlessly; hence, the influenced property is the ability to manage cryptographic keys securely.

The bug allowed entities to accept the ChangeCipherSpec message at timings different from the intended ones; hence, the attribute of the property that will be considered is the timing of the CCS message, which must satisfy two conditions to be accepted: i) there are no fragments from the handshake uncompleted (e.g. certificate validation) and ii) the next message received is Finished.

The bug that exposed the second vulnerability ([CVE-2016-7798]) consisted of a bad implementation of the Ruby Openssl gem when using the AES algorithm in Galois/Counter Mode (GCM) [], which allowed each initialization vector to be used multiple times; this resulted in weak encryption of data. The issue was caused by the initialization vector being set before the key when it should have been set after it. The attributes considered in this process are the encryption algorithm (AES-GCM), the satisfaction of the requirement of having a different initialization vector every time and the correlated certificate signing algorithm, which is also affected by this issue.

It is important to note that both the vulnerabilities described above affect the system's confidentiality; hence, confidentiality will be the only macro-property considered.

After the system receives the update, the trigger component analyses the changes, comparing the old certificates with the updated properties and attributes and extracting the following properties and attributes:
\begin{itemize}
    \item Ability to execute cryptographic mechanisms of appropriate strength and performance
    \begin{itemize}
        \item AES-GCM conditions
        \item AES-GCM key length
    \end{itemize}
    \item Ability to perform authenticated encryption algorithms
    \begin{itemize}
        \item DTLS handshake conditions
    \end{itemize}
    \item Ability to verify digital signatures
    \begin{itemize}
        \item Signature algorithm and key length
    \end{itemize}

\end{itemize}

After listing the impacted properties and attributes and making them available through the Changes function, the trigger signals a manual operator that the process requires attention.

\subsection{Manual Revision Phase}
An expert manual operator accesses the properties and attributes through the Changes function and deals with three main tasks:
\begin{itemize}
    \item According to technological standards, the operator has to assign to each attribute a list of values; in this example, they are:
    \begin{itemize}
        \item {[1]} (satisfied or not) for the AES-GCM conditions
        \item {[128, 192, 256]} for the key length of the AES-GCM algorithm
        \item {[1]} (satisfied or not) for the DTLS handshake conditions
        \item {[\texttt{sha-1WithRSAEncryption, sha-224WithRSAEncryption, sha-256WithRSAEncryption, sha-384WithRSAEncryption, sha-512WithRSAEncryption}]} for the signature algorithm and key length
    \end{itemize}
    
    \item According to her assumed knowledge, he assigns a range of scores that directly map to the values of each attribute:
    \begin{itemize}
        \item {[20]} for the AES-GCM conditions
        \item {[5, 10, 20]s} for the key length of the AES-GCM algorithm
        \item {[20]} for the DTLS handshake conditions
        \item {[5, 10, 20, 50, 70]} for the signature algorithm and key length
    \end{itemize}
    
    \item According to her assumed knowledge, he assigns a score threshold to the impacted macro-properties; in this case, to the confidentiality macro-property, he assigns a threshold of 80 and a weight of 1 (the final weighted sum is ignored for this example).
\end{itemize}

\subsection{Score Computation and Testing}
At this point, the system must compute the minimum value needed by each attribute to reach the threshold with the minimum possible effort. In this case, since the threshold is 80, each attribute needs a score of 20 and will be tested for the corresponding value:
\begin{itemize}
    \item 1 for the AES-GCM conditions
    \item 256 for the key length of the AES-GCM algorithm
    \item 1 for the DTLS handshake conditions
    \item \texttt{sha-256WithRSAEncryption} for the signature algorithm and key length
\end{itemize}

If the system holds such requirements, then the certificate can be released.

All tests were executed on a virtual machine running Linux Ubuntu version 22.04.1 using a client-server setup.
For CVE-2014-0224 the server was tested with OpenSSL version 0.9.8y, known for being vulnerable to the CCS injection attack, and version 3.0.2, which implements the security patch to the vulnerability. Both server instances were initialized with the same commands:

First, it is required to generate a new key and a certificate on the server that will be used to establish a secure SSL/TLS connection with the following command:
"openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes"; the command req is used to create a self-signed test certificate with the argument x509, and the other arguments are: i) \textbf{newkey rsa:4096} generates a new private RSA key of size 4096 bits, ii) \textbf{keyout} copies the generated key into a file named key.pem, iii) \textbf{out} copies the generated certificate into a file named cert.pem, iv) \textbf{days} specifies the validity duration of the certificate and v) \textbf{nodes} avoids encrypting the generated private key.
Next, the server can be started using the following command:
"\texttt{openssl s\_server -key key.pem -cert cert.pem -accept 44330 -www}"; the command \textbf{s\_server} implements a generic SSL/TLS server which accepts connections from remote clients speaking SSL/TLS, and the arguments are: i) \textbf{key} specifies the private key to use, ii) \textbf{cert} specifies the certificate file to use, iii) \textbf{accept} specifies the port to listen on for connections, and iv) \textbf{www} sets the server to send a status message back to the client when it connects.

On the client side, executing a script designed to check if the server is vulnerable to the CCS injection exploit is sufficient; such a script is publicly available on [nmap.org website] and uses the open-source tool Nmap []. The script works by sending a '\textit{ChangeCipherSpec}' message out of order and checking whether the server returns a '\textit{UNEXPECTED\_MESSAGE}' alert record or not. Since a non-patched server would simply accept this message, the CCS packet is sent twice in order to force an alert from the server. The server is vulnerable if the alert type is different from '\textit{UNEXPECTED\_MESSAGE}'; the script is shown in appendix B []. The output provided by the script is the following for the vulnerable server test:  

\begin{verbatim}
Starting Nmap 7.80 ( https://nmap.org ) at 2022-09-17 19:23 CEST
Nmap scan report for localhost (127.0.0.1)
Host is up (0.00012s latency).

PORT      STATE SERVICE
44330/tcp open  unknown
| ssl-ccs-injection: 
|   VULNERABLE:
|   SSL/TLS MITM vulnerability (CCS Injection)
|     State: VULNERABLE
|     Risk factor: High
|      OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h
|      does not properly restrict processing of ChangeCipherSpec messages,
|      which allows man-in-the-middle attackers to trigger use of a zero
|      length master key in certain OpenSSL-to-OpenSSL communications, and
|      consequently hijack sessions or obtain sensitive information, via
|      a crafted TLS handshake, aka the "CCS Injection" vulnerability.
|           
|     References:
|       http://www.cvedetails.com/cve/2014-0224
|       https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0224
|_      http://www.openssl.org/news/secadv_20140605.txt

Nmap done: 1 IP address (1 host up) scanned in 1.18 seconds
\end{verbatim}

and the following for the patched server test:
\begin{verbatim}
Starting Nmap 7.80 ( https://nmap.org ) at 2022-09-17 19:26 CEST
Nmap scan report for localhost (127.0.0.1)
Host is up (0.000079s latency).

PORT      STATE SERVICE
44330/tcp open  unknown

Nmap done: 1 IP address (1 host up) scanned in 0.17 seconds
\end{verbatim}

The test results show that the server running OpenSSL version 3.0.2 is no longer vulnerable to the CCS injection attack, while, with version 0.9.8y, the script highlights the presence of the vulnerability.


The test for CVE-2016-7798 was executed by replicating the bug using OpenSSL's Ruby gem; moreover, the execution was done using Ruby version 2.0.0p648, known for being affected by the bug, and Ruby version 3.1.0p0, which implements the security patch to the vulnerability. The scripts used for testing are shown in appendix \ref{IV}.The server does mainly three operations: i) waits for a message from the client, ii) encrypts the received message with the AES-256-GCM algorithm, always using the same key and iii) sends a hashed version of the encrypted message back to the client. Moreover, the server encrypts the messages setting a random initialization vector first and then the key, as suggested by [], to reproduce the bug. On the other hand, the client sends multiple times the same message to the server and counts the different ciphered texts received; the ciphered texts are extracted from the hashed texts and inserted into a set, which automatically filters out all the identical elements; the number of different ciphered texts is then the size of such set. Theoretically, the number of different ciphered texts should equal the number of sent messages.

The output of the server is the same in both versions:
\begin{verbatim}
>> Listening on port 44330
>> Received, encrypted and sent 1000000 messages
\end{verbatim}

The output resulting from the client connected to the vulnerable server is the following:
\begin{verbatim}
>> Sending 1000000 messages to the server...
>> All the messages encrypted by the server are equal
\end{verbatim}

and the output resulting from the client connected to the patched version is the following:
\begin{verbatim}
>> Sending 1000000 messages to the server...
>> The server sent 1000000 different ciphered texts
\end{verbatim}

The test proves that the vulerability is not present anymore in the patched version since the number of chiphered texts equal the number of sent messages.


The test of the algorithm AES-GCM with a key length of 256 bits was executed using a client-server setup with the Ruby language; the scripts used are shown in the appendix \ref{aes}. This test aimed to ensure the system's (server) capability to decrypt messages using the AES-256-GCM algorithm. Moreover, the test steps are as follows: i) the client encrypts a message using the AES-256-GCM algorithm and sends it to the server, ii) the server decrypts the message and sends it back to the client as plaintext and iii) the client compares the received plaintext with the original message; if all the messages are successfully decrypted the test is passed. The output of the test on the server-side is the following:
\begin{scriptsize}
\begin{verbatim}
Listening on port 44330

Received:  => 94c5710fdb955d3c785ce8b7dd13c27fdc1413478698bcb00b5165ce0d046aa46b042ca5d411d557
Decrypted: => Test message

Received:  => 2168638686b8306cfab0f91c78b539c5c6b2b691ce7653d8f9e88a475a32775702f2e383876c98b9
Decrypted: => Test message

Received:  => 94d7bcaae857db4f7cc6ced44e13002359f3945dbc2ebd8ecb60ab31eedb045855e96837355d4732
Decrypted: => Test message

Received:  => 76d28244ff06b9e4b5e6a7acffae823e8e7a3627c605ff19e19ab694a74cf6eae4cd339e5243ecef
Decrypted: => Test message

Received:  => a97de6ed0ae94ebaf7b50af087c27da8e5d71207266c00881bd5e399dbc154a422b02cf68728499e
Decrypted: => Test message
\end{verbatim}
\end{scriptsize}

and the output of the test on the client-side is the following:
\begin{verbatim}
The server decrypted the message correctly: { Test message }
The server decrypted the message correctly: { Test message }
The server decrypted the message correctly: { Test message }
The server decrypted the message correctly: { Test message }
The server decrypted the message correctly: { Test message }
The server decrypted all messages successfully!
\end{verbatim}

The output confirms the server's capability of decrypting messages with the AES-256-GCM algorithm.




The test of the sha-256WithRSAEncryption signature algorithm was also executed using a client-server setup with the Ruby language; the scripts used are shown in the appendix \ref{sig}. This test aimed to verify the integrity of the system's (server) certificate when generated using the sha-256WithRSAEncryption algorithm.The test's steps are as follows: i) the client connects to the server and sends an \textit{HELLO} message, ii) the server accepts the connection and replies to the \textit{HELLO} message with its certificate, iii) the client receives the server's certificate and extracts the server's public key from it, iv) the client uses the server's public key to encrypt a document and sends the result to the server, v) the server receives the encrypted document and decrypts it with its private key, vi) the server uses its private key to sign the decrypted document and sends the result to the client and vii) the client receives the signed document and verifies the authenticity of the signature usign the server's public key; if such verification succeeds the test is passed.

The output of the test on the server-side is the following:
\begin{verbatim}
>> Server listening on port 44330

>> New client connected

>> Received client's HELLO message, certificate sent

>> Received document encrypted by the client with this server's public key
>> Decrypted text:
This is an example document

>> Document signed with this server's private key

>> Signed document sent to the client

>> The client terminated the connection
\end{verbatim}

and the output of the test on the client-side is the following:
\begin{verbatim}
>> Connected to the server at 127.0.0.1:44330

>> HELLO message sent

>> Received server's certificate:
-----BEGIN CERTIFICATE-----
MIIFuzCCA6OgAwIBAgIUMo/2YlijMS2n80NQTCOWYPAg8UAwDQYJKoZIhvcNAQEL
BQAwbTELMAkGA1UEBhMCaXQxCzAJBgNVBAgMAnZhMRIwEAYDVQQHDAlnYWxsYXJh
dGUxDjAMBgNVBAoMBXVuaW1pMQ8wDQYDVQQDDAZtYXR0ZW8xHDAaBgkqhkiG9w0B
CQEWDXRlb0BnbWFpbC5jb20wHhcNMjIwOTIwMTU1MzAxWhcNMjMwOTIwMTU1MzAx
WjBtMQswCQYDVQQGEwJpdDELMAkGA1UECAwCdmExEjAQBgNVBAcMCWdhbGxhcmF0
ZTEOMAwGA1UECgwFdW5pbWkxDzANBgNVBAMMBm1hdHRlbzEcMBoGCSqGSIb3DQEJ
ARYNdGVvQGdtYWlsLmNvbTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIB
ALi7TCyfIx9vJX4aofx0KlLwBctf+oKDn+xUduDJh43d31WvBGlomfUYxGGzlsWm
UXUaJ+mNf57kEra+zoIPVF2vIExr0CD7HpaYzRnWQGb5PFQkSppmfpMOzRTu94R+
7d47rMSNKY8g0G3gwhZMcVViBKUmDmoUccn1piW4s2Ur+esWfvb9qhBHJ8uqhL7h
2sFStjZKhIiMyW0zJcepnD9QikNme76X2fmYPS6pb7oMhdYurj4ILbqJctazmLMi
w2VLas74eVD9SA9WcszNIgNUBh7adTXHHPM9t6YGzYLGkn0PQ+vi5BqKPaTWdY8x
s6OFgh37klDPgvOAKDCVMRUkGSRzOpB/0k5wu6t9R6XY4mpa3BTxvEoee3B6Wx6z
WRJuemjx26JGw7D+enDXEw8+DCj532so1m0ytHKTrQd0NI5xztUJUdFE1e0/EnOR
m0Dq9/FYE1acpJnNo+FRApD1zcd08UdSF1DNNbVv27EVWCVHJFu7BlSl6tHvFroW
pSMkZtk2JVmkkAfrqJDdMhz7EZ65w9NSYy7DQEhYiYequnVei7lAHRVONJ3nQffw
EasNyDKG37WwarMFoqib4/8GDMtU0j/osQp9UAslMEBYQHFEakQRq8It5ACsznkw
AZy7ojZiQSkFdjqJ7cDyJhdiQcv9dKc0kIORKbZQ/17rAgMBAAGjUzBRMB0GA1Ud
DgQWBBTatWBPOpLFToMvhyV4q3vcRG+cQTAfBgNVHSMEGDAWgBTatWBPOpLFToMv
hyV4q3vcRG+cQTAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4ICAQA0
x7/Aab/6ZI7YVrwUZhkL49SfHQjP8aTtX2exJCN/IylYnlmdtf44PBYGSEK4dMP6
yCKPgtFTH1nFV/IndgQiy/bdyqGZa/wQmvP4lQp2AlyasTF+5uBmihdR7K11H+kA
8jdO2t0RqcVak+9M+F1uzCIAgu4fL2oMDwekfkI7ZBYYZdhMOdQItSJgN4bMJufj
UkzVwgy9q9UMEIRyCyXjI9HKF1rLYm7MtqBLBl90PT3jqgxqAgjOIaNQecg4pM1Z
PqVjHDSiIZwLvwdff59Aoaxiuq7lKk23A9RNcBGcv4dQCkzMWs4z6QL8pfNQJAL4
49iVcsSlxuYOtj3BCIO8+TJS+VBDiRljd3ekVFdObXrCeACGVm78sBXMmJH/UTFX
1kaJ4vkGblqlj2Ye3mpmc3H8qF3stRMv6dzWCJDggqA2NJI38Jc4u4/yXicrBmdv
6IwJe9JtYqJ5bRYE1Ig9Lb0y6SF7Hh4mIaKZGtwJgxf6jqIxuZAFM1Yv9S0wqUN+
78G+YsjA87T+6jHV1raXXTidGHGdPwYK/scQ7PvGUUk0Tl9YOagnxvbIeQRmNmLz
aj0YDPtAB0HJsqhZblVKqougfiRWyFaabnbunal5Vffs5BOfbDqIBFP5EZSCB0oS
fywDFN1Go/TGzqwrOrkwIE8S1PMs95es6qTZxzyJkQ==
-----END CERTIFICATE-----


>> Extracted server's public key:
-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAuLtMLJ8jH28lfhqh/HQq
UvAFy1/6goOf7FR24MmHjd3fVa8EaWiZ9RjEYbOWxaZRdRon6Y1/nuQStr7Ogg9U
Xa8gTGvQIPselpjNGdZAZvk8VCRKmmZ+kw7NFO73hH7t3jusxI0pjyDQbeDCFkxx
VWIEpSYOahRxyfWmJbizZSv56xZ+9v2qEEcny6qEvuHawVK2NkqEiIzJbTMlx6mc
P1CKQ2Z7vpfZ+Zg9LqlvugyF1i6uPggtuoly1rOYsyLDZUtqzvh5UP1ID1ZyzM0i
A1QGHtp1Nccc8z23pgbNgsaSfQ9D6+LkGoo9pNZ1jzGzo4WCHfuSUM+C84AoMJUx
FSQZJHM6kH/STnC7q31HpdjialrcFPG8Sh57cHpbHrNZEm56aPHbokbDsP56cNcT
Dz4MKPnfayjWbTK0cpOtB3Q0jnHO1QlR0UTV7T8Sc5GbQOr38VgTVpykmc2j4VEC
kPXNx3TxR1IXUM01tW/bsRVYJUckW7sGVKXq0e8WuhalIyRm2TYlWaSQB+uokN0y
HPsRnrnD01JjLsNASFiJh6q6dV6LuUAdFU40nedB9/ARqw3IMobftbBqswWiqJvj
/wYMy1TSP+ixCn1QCyUwQFhAcURqRBGrwi3kAKzOeTABnLuiNmJBKQV2OontwPIm
F2JBy/10pzSQg5EptlD/XusCAwEAAQ==
-----END PUBLIC KEY-----


>> Encrypting the following document:
This is an example document

>> Encrypted document sent to the server

>> Received document signed with the server's private key

>> The server's signature is authentic

>> Connection terminated
\end{verbatim}

The output confirms the integrity of the server's certificate generated with the ha-256WithRSAEncryption signature algorithm.